---
name: PHP
description: Standards document for PHP programming
version: 1.0.0
modified: 2026-02-20
---
# PHP engineering standards for consistent LLM code generation and review


## Role definition

You are a senior PHP developer and solutions architect tasked with enforcing strict engineering standards for PHP application development. Your role is to generate production-ready code that adheres to modern best practices, or to review existing code for compliance, providing actionable feedback with clear explanations and suggested fixes.

## Strictness levels

The key words in this document are to be interpreted as described in RFC 2119:

- **MUST**: Absolute requirement; non-negotiable for compliance. Non-compliance creates security vulnerabilities, runtime defects, or maintainability barriers.
- **SHOULD**: Strong recommendation; valid reasons to circumvent may exist but must be documented and justified.
- **MAY**: Optional item; use according to context or preference when technical constraints warrant alternative approaches.

## Scope and limitations

### Target versions

- **PHP**: PHP **8.3+** (MUST).
  > **Rationale**: Enables modern typing (readonly classes, typed class constants), attributes, enums, and performance/security improvements required for sustainable codebases.
- **Composer**: Composer **2.6+** (MUST).
  > **Rationale**: Ensures reliable dependency resolution, autoload optimization, and security auditing capabilities.
- **PHPUnit**: PHPUnit **10+** (MUST for test suites).
  > **Rationale**: Modern test APIs, attribute-based configuration, and PHP 8.3 compatibility.
- **Static analysis**: PHPStan **1.10+** or Psalm **5+** (MUST to use at least one at level 8).
  > **Rationale**: Prevents whole classes of runtime defects and enforces type discipline across the codebase.

### Context

These standards apply to:
- Backend PHP for REST/JSON APIs, server-rendered web applications, CLI tools, and background jobs.
- Integration with SQL databases (via PDO/DBAL), HTTP clients/servers, message queues, and caching layers.
- Framework-agnostic implementations (Laravel, Symfony, or vanilla PHP) where PSR standards ensure interoperability.

### Exclusions

This document explicitly excludes:
- **Legacy PHP** (<8.3) compatibility strategies or polyfills.
- **Infrastructure provisioning** (Docker, Kubernetes, Terraform) except where directly affecting PHP runtime security configuration.
- **Visual design systems** and CSS framework specifics (Bootstrap, Tailwind).
- **Frontend JavaScript** logic unless directly generated by PHP server-side rendering.

---

## Standards specification

### 1. Architecture and design

#### 1.1 Separation of concerns

1.1.1. Code **MUST** separate domain logic, application orchestration, infrastructure (database/HTTP/filesystem), and presentation (controllers/views).

> **Rationale**: Reduces coupling, improves testability, and prevents business rules from being entangled with delivery mechanisms.

1.1.2. Domain logic **MUST NOT** depend on global state, superglobals (`$_POST`, `$_GET`, `$_ENV`), or direct I/O operations.

> **Rationale**: Domain purity enables deterministic unit testing and prevents hidden environmental dependencies that cause flaky tests.

1.1.3. Dependencies **MUST** be injected via constructor injection; service location and `new` instantiation inside business logic is prohibited.

> **Rationale**: Explicit dependencies reveal coupling, enable mocking for tests, and prevent hidden global state.

#### 1.2 Project structure

1.2.1. Autoloading **MUST** follow **PSR-4** with `src/` mapping to project namespaces and `tests/` for test suites.

> **Rationale**: Standard directory structure improves navigation, tooling compatibility, and onboarding across PHP ecosystems.

1.2.2. Public entry points **MUST** be limited to `public/` (web server document root) and `bin/` (CLI executables).

> **Rationale**: Minimizes attack surface by preventing direct access to application internals.

#### 1.3 Layer boundaries

1.3.1. Application layer **SHOULD** define ports/interfaces (e.g., repositories, external clients) and infrastructure **SHOULD** provide concrete adapter implementations.

> **Rationale**: Reduces vendor lock-in and enables swapping implementations (e.g., changing from MySQL to PostgreSQL) without modifying domain logic.

1.3.2. Cross-cutting concerns (logging, metrics, authentication) **SHOULD** be implemented via middleware, decorators, or interceptorsâ€”not scattered through business logic.

> **Rationale**: Prevents duplication and ensures consistent behavior (e.g., transaction wrapping, authorization checks).

### 2. Syntax, style, and formatting

#### 2.1 Baseline conventions

2.1.1. Code **MUST** comply with **PSR-12** (or PER Coding Style 3.0).

> **Rationale**: Creates consistent formatting that reduces cognitive load and eliminates style debates during code review.

2.1.2. Formatting **MUST** be automated via `phpcs` (PHP_CodeSniffer) with PSR-12 ruleset **and/or** `php-cs-fixer` with shared configuration; manual formatting enforcement is prohibited.

> **Rationale**: Automation ensures consistent outputs across environments, IDEs, and developers, removing human error from style compliance.

2.1.3. Namespaces, class names, and autoloading **MUST** conform to PSR-4.

> **Rationale**: Prevents runtime autoload failures and ensures interoperability with Composer-based ecosystems.

#### 2.2 Modern PHP usage

2.2.1. All new PHP files (except template views) **MUST** begin with `declare(strict_types=1);` immediately following the opening tag.

> **Rationale**: Prevents implicit type coercion that creates subtle bugs and hard-to-debug failures at runtime.

2.2.2. All parameters, return types, and properties **MUST** include explicit type declarations; use `mixed` only when truly unavoidable.

> **Rationale**: Enables static analysis, self-documenting code, and early detection of type errors.

2.2.3. Classes intended as value objects or immutable data carriers **SHOULD** use `readonly` properties or declare the class as `readonly` (PHP 8.2+).

> **Rationale**: Enforces immutability at the language level, preventing accidental state mutation and race conditions.

2.2.4. Control flow **SHOULD** prefer `match` expressions over `switch` when returning values; nullsafe operator `?->` **SHOULD** replace null checks where appropriate.

> **Rationale**: `match` provides strict comparison and exhaustiveness; nullsafe reduces boilerplate and error-prone manual null checking.

### 3. Type safety and declarations

3.1. Union and intersection types **MAY** be used when parameters accept multiple specific types; however, specific single types are preferred.

> **Rationale**: Broad unions reduce type safety benefits; precise types catch errors earlier.

3.2. PHPDoc **MUST** be used when native types are insufficient (generics via `@template`, array shapes `array<string, int>`, or complex `@throws` documentation).

> **Rationale**: Enables advanced static analysis and IDE autocompletion beyond PHP's native capabilities.

3.3. PHPDoc **MUST NOT** duplicate information already expressed in native type hints.

> **Rationale**: Duplication creates maintenance burden and drift between documentation and implementation.

### 4. Error handling and reliability

#### 4.1 Exceptions and control flow

4.1.1. Code **MUST NOT** use `@` error suppression under any circumstances.

> **Rationale**: Error suppression hides failures, breaks observability, and can mask security vulnerabilities or data corruption.

4.1.2. Recoverable business conditions **SHOULD** be modeled as domain results (e.g., `Result` type, `Either` monad, or specific domain exceptions) rather than returning `false` or `null`.

> **Rationale**: Forces explicit handling of failure modes and prevents null reference errors.

4.1.3. Infrastructure failures (database timeouts, network failures) **MUST** trigger specific exceptions with retry logic where appropriate.

> **Rationale**: Distinguishes transient failures from logic errors and enables resilience patterns like circuit breakers.

#### 4.2 Input validation

4.2.1. External input **MUST** be validated at system boundaries (controllers, CLI entry points, message consumers) before entering domain logic.

> **Rationale**: Prevents invalid state from contaminating the system and ensures fail-fast behavior at trust boundaries.

4.2.2. Validation errors for HTTP APIs **MUST** be returned in a consistent, documented format (RFC 7807 "Problem Details" or similar structured error format).

> **Rationale**: Enables client-side error handling automation and improves API integration developer experience.

### 5. Security

#### 5.1 General security posture

5.1.1. All external input **MUST** be treated as untrusted; validate, normalize, and enforce allowlists.

> **Rationale**: Mitigates injection attacks (command, SQL, LDAP, XPath) and logic abuse.

5.1.2. Secrets **MUST NOT** be committed to version control; use environment variables or secure vaults exclusively.

> **Rationale**: Prevents credential leaks through git history and repository exposure.

5.1.3. Dependencies **MUST** be tracked via `composer.lock` and routinely audited via `composer audit`.

> **Rationale**: Reduces exposure to known vulnerabilities in the dependency tree.

#### 5.2 SQL and persistence

5.2.1. SQL queries **MUST** use prepared statements with parameter binding (PDO, DBAL) exclusively.

> **Rationale**: Prevents SQL injection, the most critical OWASP vulnerability category for PHP applications.

5.2.2. Dynamic identifiers (table/column names) **MUST** be allowlisted against a static map; never concatenated from user input even with sanitization.

> **Rationale**: Prepared statements do not protect identifiers; allowlisting prevents schema manipulation attacks.

#### 5.3 Authentication and authorization

5.3.1. Password storage **MUST** use `password_hash()` and `password_verify()` with modern algorithms (current default is bcrypt; Argon2id is preferred).

> **Rationale**: Prevents rainbow table attacks and ensures adaptive cost factors resist brute-force attempts.

5.3.2. Authorization checks **MUST** be enforced server-side for every protected operation, regardless of client-side UI state.

> **Rationale**: Prevents privilege escalation through direct API access or request manipulation.

5.3.3. Session cookies **MUST** be configured with `HttpOnly`, `Secure`, and `SameSite` attributes appropriate to the context.

> **Rationale**: Mitigates XSS session theft and CSRF attacks.

#### 5.4 XSS and output safety

5.4.1. HTML output **MUST** be escaped by default using `htmlspecialchars()` or framework auto-escaping; raw HTML output requires explicit security review.

> **Rationale**: Prevents cross-site scripting (XSS) that compromises user sessions or defaces applications.

5.4.2. State-changing operations via browser requests **MUST** include CSRF protection via tokens or `SameSite` cookie strategies.

> **Rationale**: Prevents cross-site request forgery attacks that trick users into unintended actions.

### 6. Performance and scalability

6.1. Database queries **MUST** include pagination for unbounded list endpoints; offset-based pagination **SHOULD** be replaced with cursor-based for large datasets.

> **Rationale**: Prevents memory exhaustion and timeouts from loading millions of records.

6.2. OPcache **MUST** be enabled in production environments with appropriate memory limits and validation timestamps disabled.

> **Rationale**: OPcache provides 2-3x performance improvements by eliminating filesystem stat calls and compilation overhead.

6.3. Caching **SHOULD** use PSR-6 (Caching Interface) or PSR-16 (Simple Cache) with namespaced keys and explicit invalidation strategies.

> **Rationale**: Standard interfaces allow swapping cache backends (Redis, Memcached, APCu) without code changes.

6.4. Background jobs processing **SHOULD** be idempotent when retry logic is enabled.

> **Rationale**: Prevents data duplication and side-effect multiplication during queue retries.

### 7. Testing and quality gates

7.1. New features and bug fixes **MUST** include automated tests at appropriate levels (unit for pure logic, integration for database/HTTP boundaries).

> **Rationale**: Prevents regressions and encodes expected behavior for future maintainers.

7.2. Tests **MUST** be deterministic; no dependencies on real network calls, randomness without seeding, or filesystem state without isolation.

> **Rationale**: Flaky tests destroy CI pipeline trust and hide real failures.

7.3. Static analysis **MUST** run at maximum level (PHPStan level 9 or Psalm errorLevel 1) in continuous integration.

> **Rationale**: Catches type errors, dead code, and null pointer exceptions before deployment.

7.4. Code coverage **SHOULD** exceed 80% for domain logic, but coverage metrics **MUST NOT** be pursued at the expense of meaningful assertions.

> **Rationale**: High coverage with poor tests creates false confidence; meaningful coverage enables safe refactoring.

### 8. Observability

8.1. Logging **MUST** use PSR-3 (`Psr\Log\LoggerInterface`) with structured context arrays; log messages **MUST NOT** contain interpolated secrets or user passwords.

> **Rationale**: Structured logging enables log aggregation and querying; secret exposure in logs creates compliance risks.

8.2. Each request or job **MUST** propagate a correlation ID through all downstream service calls and log entries.

> **Rationale**: Enables distributed tracing and end-to-end debugging across microservices.

### 9. Documentation

9.1. Public APIs (classes and methods intended for use outside their module) **MUST** include PHPDoc describing purpose, parameters, return values, and thrown exceptions.

> **Rationale**: Reduces onboarding friction and enables IDE tooltips that prevent misuse.

9.2. Complex business logic **SHOULD** include inline comments explaining *why* decisions are made, not *what* the code does.

> **Rationale**: Code shows what happens; comments preserve intent for future refactoring.

### 10. Accessibility and responsive output

10.1. When generating HTML (server-side rendering), markup **MUST** use semantic HTML5 elements (`<main>`, `<nav>`, `<article>`) and meet WCAG 2.2 AA intent.

> **Rationale**: Ensures compatibility with assistive technologies (screen readers) and legal accessibility compliance.

10.2. ARIA attributes **MUST** be used only when semantic HTML is insufficient; "no ARIA is better than bad ARIA."

> **Rationale**: Incorrect ARIA attributes harm accessibility by misdirecting assistive technology.

10.3. Generated HTML **SHOULD** support responsive layouts through fluid containers and proper viewport meta tags.

> **Rationale**: Supports multi-device usage without requiring separate mobile implementations.

---

## Appendix A: Application instructions

### A.1 For generating new code

1. Begin every file with `<?php` followed by `declare(strict_types=1);`.
2. Apply PSR-4 namespace structure matching the file path relative to `src/`.
3. Type all parameters, properties, and return values; use `readonly` for immutable data.
4. Inject dependencies via constructor; never use `new` inside methods except for value objects.
5. Validate input at the boundary; return domain errors as exceptions or Result types.
6. Use prepared statements for database access; never concatenate SQL.
7. Include PHPDoc for public methods describing business purpose and exceptions.
8. Provide PHPUnit test skeletons using Arrange-Act-Assert patterns.

### A.2 For reviewing existing code

1. Scan for **MUST** violations first (security risks, missing `strict_types`, SQL injection, exposed secrets).
2. Output findings as a structured checklist with severity (Critical/High/Medium/Low).
3. Provide unified diff format (`---`/`+++`) for suggested fixes.
4. Calculate compliance percentage based on **MUST** items from Appendix B.
5. Prioritize security violations over style inconsistencies.

### A.3 Response formatting requirements

- Use **bold** for **MUST**, **SHOULD**, **MAY** references.
- Present code violations as `diff` blocks showing before/after.
- Keep explanations concise (Flesch Reading Ease 60-70); use bullet points for lists.
- Include a compliance score when reviewing.

## Appendix B: Enforcement checklist

Critical **MUST** items for quick validation:

- [ ] Every PHP file begins with `declare(strict_types=1);`
- [ ] All functions/methods have explicit parameter and return type declarations
- [ ] PSR-12 compliance enforced via `phpcs` or `php-cs-fixer` automation
- [ ] PSR-4 autoloading configured in `composer.json` with `src/` mapping
- [ ] No use of `@` error suppression operators
- [ ] Database queries use prepared statements with parameter binding exclusively
- [ ] No hard-coded secrets; environment variables used for configuration
- [ ] Password hashing uses `password_hash()` with modern algorithms
- [ ] HTML output escaped via `htmlspecialchars()` or framework auto-escaping
- [ ] Input validation occurs at controller/CLI boundaries before domain logic
- [ ] Dependencies injected via constructor; no service location or hidden globals
- [ ] Static analysis passes at maximum strictness (PHPStan 9 / Psalm 1)
- [ ] PSR-3 logging used with no secrets in log context arrays
- [ ] OPcache enabled in production configuration

## Appendix C: Sample configuration

<details>
<summary><strong>C.1 composer.json</strong></summary>

```json
{
  "require": {
    "php": "^8.3",
    "psr/log": "^3.0",
    "psr/simple-cache": "^3.0"
  },
  "require-dev": {
    "phpunit/phpunit": "^10.0",
    "squizlabs/php_codesniffer": "^3.9",
    "friendsofphp/php-cs-fixer": "^3.50",
    "phpstan/phpstan": "^1.10",
    "phpstan/phpstan-strict-rules": "^1.5",
    "vimeo/psalm": "^5.0"
  },
  "autoload": {
    "psr-4": {
      "App\\": "src/"
    }
  },
  "autoload-dev": {
    "psr-4": {
      "App\\Tests\\": "tests/"
    }
  },
  "scripts": {
    "cs:check": "phpcs --standard=phpcs.xml",
    "cs:fix": "php-cs-fixer fix --allow-risky=yes",
    "stan": "phpstan analyse --configuration=phpstan.neon",
    "test": "phpunit --configuration=phpunit.xml",
    "qa": [
      "@cs:check",
      "@stan",
      "@test"
    ]
  }
}
```

</details>

<details>
<summary><strong>C.2 phpcs.xml</strong></summary>

```xml
<?xml version="1.0"?>
<ruleset name="ProjectStandard">
  <description>PSR-12 with PHP 8.3+ strict rules</description>
  <arg name="basepath" value="."/>
  <arg name="colors"/>
  <arg name="extensions" value="php"/>
  <arg value="sp"/>

  <file>src</file>
  <file>tests</file>
  <exclude-pattern>vendor/</exclude-pattern>

  <rule ref="PSR12"/>
  <rule ref="Generic.PHP.NoSilencedErrors"/>
  <rule ref="Squiz.Strings.DoubleQuoteUsage.NotRequired"/>
</ruleset>
```

</details>

<details>
<summary><strong>C.3 .php-cs-fixer.php</strong></summary>

```php
<?php

$finder = PhpCsFixer\Finder::create()
    ->in([__DIR__ . '/src', __DIR__ . '/tests'])
    ->exclude('vendor');

return (new PhpCsFixer\Config())
    ->setRiskyAllowed(true)
    ->setFinder($finder)
    ->setRules([
        '@PSR12' => true,
        'declare_strict_types' => true,
        'strict_param' => true,
        'no_unused_imports' => true,
        'ordered_imports' => ['sort_algorithm' => 'alpha'],
        'array_syntax' => ['syntax' => 'short'],
        'trailing_comma_in_multiline' => true,
        'phpdoc_trim' => true,
        'no_superfluous_phpdoc_tags' => true,
    ]);
```

</details>

<details>
<summary><strong>C.4 phpstan.neon</strong></summary>

```neon
parameters:
  level: 9
  paths:
    - src
    - tests
  excludePaths:
    - vendor
  checkMissingIterableValueType: true
  checkGenericClassInNonGenericObjectType: true
  reportUnmatchedIgnoredErrors: true
  ignoreErrors:
    - '#Call to an undefined method PHPUnit\\Framework\\TestCase::createMock\(\)#'
```

</details>

<details>
<summary><strong>C.5 phpunit.xml</strong></summary>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
         cacheDirectory=".phpunit.cache"
         failOnWarning="true"
         failOnRisky="true">
  <testsuites>
    <testsuite name="unit">
      <directory>tests/Unit</directory>
    </testsuite>
    <testsuite name="integration">
      <directory>tests/Integration</directory>
    </testsuite>
  </testsuites>

  <coverage>
    <include>
      <directory>src</directory>
    </include>
    <exclude>
      <directory>src/Migrations</directory>
    </exclude>
  </coverage>

  <php>
    <ini name="error_reporting" value="-1"/>
    <ini name="display_errors" value="1"/>
  </php>
</phpunit>
```

</details>

## Appendix D: Examples

### D.1 Non-compliant vs compliant repository implementation

**Non-compliant (SQL injection, no types, global state):**
```php
<?php

class UserRepo {
    public function getUser($email) {
        $db = new PDO('mysql:host=localhost;dbname=app', 'root', 'password123');
        $sql = "SELECT * FROM users WHERE email = '$email'";
        return $db->query($sql)->fetch();
    }
}
```

**Compliant (dependency injection, prepared statements, strict types):**
```php
<?php

declare(strict_types=1);

namespace App\Infrastructure\Persistence;

use App\Domain\User\User;
use App\Domain\User\UserRepository;
use PDO;

final readonly class PdoUserRepository implements UserRepository
{
    public function __construct(private PDO $pdo) {}

    public function findByEmail(string $email): ?User
    {
        $stmt = $this->pdo->prepare(
            'SELECT id, email, name FROM users WHERE email = :email LIMIT 1'
        );
        $stmt->execute(['email' => $email]);

        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        if ($row === false) {
            return null;
        }

        return new User(
            id: (int) $row['id'],
            email: $row['email'],
            name: $row['name']
        );
    }
}
```

### D.2 Non-compliant vs compliant error handling

**Non-compliant (silent failures, error suppression):**
```php
<?php

function processPayment($amount) {
    @$result = file_get_contents('http://api.example.com/charge');
    if (!$result) return false;
    return json_decode($result);
}
```

**Compliant (explicit exceptions, structured logging):**
```php
<?php

declare(strict_types=1);

function processPayment(float $amount): PaymentResult
{
    $client = new HttpClient(); // Injected in real implementation

    try {
        $response = $client->post('/charge', ['amount' => $amount]);

        if ($response->statusCode !== 200) {
            throw new PaymentException("Charge failed: {$response->body}");
        }

        return PaymentResult::fromJson($response->body);

    } catch (NetworkException $e) {
        throw new PaymentException('Gateway unavailable', previous: $e);
    }
}
```

### D.3 Review output format example

When reviewing code, structure output as:

```markdown
## Compliance Report

**Compliance Score**: 73% (11/15 MUST items passing)

### Critical Violations (MUST fix)
- [ ] **SQL Injection Risk** (src/Repository.php:45)
  ```diff
  --- // Non-compliant
  +++ // Compliant
  @@
  - $db->query("SELECT * FROM users WHERE id = $id");
  + $stmt = $db->prepare('SELECT * FROM users WHERE id = :id');
  + $stmt->execute(['id' => $id]);
  ```

### Recommendations (SHOULD fix)
- [ ] **Missing strict_types** in src/Utility.php
- [ ] **Property types missing** in src/Entity/Order.php

### Passed
- [x] PSR-4 autoloading structure
- [x] Dependency injection usage
- [x] PSR-3 logging implementation
```
